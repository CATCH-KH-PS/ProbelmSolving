# 경주로 건설



```c++
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <iostream>
using namespace std;

int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};
typedef struct s_car{
    int y;
    int x;
    int cost;//비용
    int pre_d;//이전 방향
}t_car;
int solution(vector<vector<int>> board) {
    int check[25][25][2];
    for (int i = 0; i < 25; i++)
    {
        for (int j = 0 ;j  <25; j++)
        { 
            check[i][j][1] = 2147483647;
            check[i][j][0] = 2147483647;
        }
    }
    int answer = 2147483647;
    queue<t_car> q;
    t_car car;
    car.y = 0;
    car.x = 0;
    car.cost = 0;
    car.pre_d = -1;//시작이므로 이전 방향이 없다.
    int n = board.size();
    check[0][0][0] = 1;
    check[0][0][1] = 1;
    q.push(car);
    while (!q.empty())
    {
        int y = q.front().y;
        int x = q.front().x;
        int pre_d = q.front().pre_d;
        int cost = q.front().cost;
        if (x == n - 1 && y == n - 1)
            answer = min(answer, cost);
        q.pop();
        for (int i = 0 ; i < 4; i++)
        {
            int ny = y + dy[i];
            int nx = x + dx[i];
            if (ny < n && ny >= 0 && nx < n && nx >= 0)
            {
                if (board[ny][nx] == 0)
                {
                   
                     t_car ncar;
                     ncar.y = ny;
                    ncar.x = nx;
                    ncar.pre_d = i;
                     ncar.cost = cost + 100;
                    if (i != pre_d && pre_d != -1)
                    {
                        ncar.cost += 500;
                        if (check[ny][nx][1] >= ncar.cost)
                        {
                             q.push(ncar);
                           check[ny][nx][1] = ncar.cost;
                        }
                    }
                    else
                    {
                        if (check[ny][nx][0] >= ncar.cost)
                    {
                         q.push(ncar);
                         check[ny][nx][0] = ncar.cost;
                    }
                    }
                }
            }
        }
    }
    return answer;
}
```



## 고찰

check배열을 cost로 비교해야 하고, check배열이 2개가 필요한 bfs 문제이다.