# 최대로 먹을 수 있는 경우에 대해서, 딱히 알고리즘이 존재하지 않을 것이다.
# "물고기가 움직이고 상어가 움직인다. " 이 동작을 반복하면서 경우의 수가 가지를 뻣어 나가므로 재귀로 푼다.
# 경우의 수는, 상어가 어떤 물고기를 먹냐에 의해 갈라지므로, 지도를 복사해가며 넘겨야한다.
# 각각의 경우에 대해, 물고기와 상어를 이동시켜야 하므로 "지도"를 전역변수로 선언하면 안됨

# int map[][]은 해당 좌표에 몇번 번호의 물고기가 있는지를 담는다.
# info fish[ x ]는 x번 물고기가 위치한 좌표와 방향, 그리고 먹혔는지 아닌지를 담고있다.
# 구조체 2차원 배열을 선언할 수도 있었으나, x번 물고기가 어느 좌표에 위치해있는지 계속 찾는 것을 막기위해 두개의 자료형 선언

int main(){
   //입력부
   //재귀함수
   //정답 선택
}의 로직으로 작성

재귀함수
void recursion( ~~ ){
  1. map을 카피
  2. 상어가 위치할 공간의 물고기를 eaten 처리한다.
  3. for문으로 모든 물고기 이동
  4. 상어가 먹을 수 있는 물고기들의 "좌표 벡터"를 반환하는 함수
  5. 좌표벡터가 비어있으면, return한다. (더이상 먹을 물고기가 없다는 의미) -> 이 부분이 기저조건이 된다.
  6. 5번이 아니라면, 각각 좌표에 상어를 두고 recursion함수를 재귀호출한다.
} 
